# Pitfalls Research

**Domain:** Plugin marketplace bridge / registry tooling / Go Bubble Tea TUI extension
**Researched:** 2026-02-24
**Confidence:** MEDIUM — grounded in codebase analysis and established patterns from registry tooling (npm, Homebrew, plugin systems). External search unavailable; confidence reflects training knowledge + codebase inspection.

---

## Critical Pitfalls

### Pitfall 1: Format Assumption Drift — Generated Manifest Breaks Silently

**What goes wrong:**
Chaparral generates `marketplace.json` and `plugin.json` in Claude Code's native format. If Claude Code changes its schema (adds required fields, renames keys, changes how sources are resolved), the generated files silently become invalid. The user publishes. Other users try to install. It fails. The error appears at install time, not at generation time — potentially hours or days later, in another repo, by another user.

**Why it happens:**
Generator tools assume the target format is stable. They rarely have a validation step against the actual consumer (Claude Code's parser). Since the schema lives in Claude Code's codebase, not in a published spec, there is no machine-readable contract to validate against. Version numbers in the manifest may not be checked until install time.

**How to avoid:**
- Never hardcode field names as bare strings across the codebase. Define a single `PluginManifest` and `MarketplaceManifest` struct in Go — one source of truth for the format.
- Add a `chaparral validate` command that checks generated files against expected structure before pushing.
- Store the Claude Code format version the generator targets (e.g., a comment or a `_generated_by` field) so format drift is visible.
- Write a test that round-trips a known-good `plugin.json` through the generator and compares output.

**Warning signs:**
- Multiple places in the codebase building JSON by string concatenation or map literals instead of marshaling from a typed struct.
- No test that asserts the exact shape of generated output.
- "Generated by" comment referencing a version number that hasn't been updated in months.

**Phase to address:**
Manifest generation phase. Before any publish capability exists. Typed structs and a validate command must precede any GitHub push functionality.

---

### Pitfall 2: "Publish" With No Confirmation = Accidental Public Commits

**What goes wrong:**
Shelling out to `git push` inside a Bubble Tea command without explicit user confirmation pushes to the remote. The TUI is keyboard-driven — a mistyped key, a confirmation dialog that accepts on any keypress, or a missing "are you sure?" step means the user publishes before they're ready. A private marketplace goes public. Credentials-adjacent data (repo paths, skill names) get committed publicly.

**Why it happens:**
TUI tools are fast-and-keypress-driven. In CLI tools, "publish" usually requires a separate explicit command. In TUIs, the same interface used for local operations (sync, refresh) gets extended to destructive remote operations — and the interaction model doesn't automatically create friction. The DEFAULT behavior in most TUI frameworks is "keypress executes immediately."

**How to avoid:**
- Any publish/push operation requires a two-step confirm: a dedicated confirmation view (not just a dialog) that shows exactly what will be committed, what files will change, and which remote will receive the push.
- Never trigger git push from a single keypress. Require typing "publish" or pressing a two-key chord (e.g., `ctrl+p`) that cannot be accidentally hit during normal navigation.
- Show a diff of what `.claude-plugin/` files will be created or changed before the push executes.
- The confirmation view should be a new TUI view (`viewPublishConfirm`), not a modal — so the user can scroll/read before committing.

**Warning signs:**
- Publish triggers from a single letter key (like `p`) in the main dashboard view.
- Confirmation is handled by a `tea.KeyMsg` handler that accepts on `"enter"` without a dedicated view transition.
- No pre-publish diff shown.

**Phase to address:**
GitHub publishing phase. Before wiring up any `git push` shell-out, implement the confirmation view and diff preview.

---

### Pitfall 3: Bubble Tea Model Bloat — One Model To Rule Them All

**What goes wrong:**
The existing `Model` struct already has 12 fields. Adding marketplace state (available plugins, installed plugins, publish status, marketplace scan results, remote query results, selected plugin for install) to the same struct creates an unwieldy 20+ field model. `Update()` becomes a massive switch statement with hundreds of lines. State that belongs to one view leaks into others. Debugging becomes painful: which fields are valid in which view?

**Why it happens:**
It's the path of least resistance when extending a Bubble Tea app. The existing model works, the new feature needs state, so fields get appended. Nobody refactors until it's too late.

**How to avoid:**
- Before adding marketplace state, extract the existing local-skills state into a sub-model or a `localState` struct embedded in `Model`.
- Create a `marketplaceState` struct for marketplace-specific state that is nil/zero when not active.
- Consider a parent model that delegates to child models (`localModel`, `marketplaceModel`) via the standard Bubble Tea composition pattern — each child handles its own `Update()` and `View()`.
- Keep `Model.Update()` as a router, not a handler. Route to sub-model handlers by current view/tab.

**Warning signs:**
- `Model` struct exceeds 15 fields.
- `Update()` function exceeds 80 lines.
- Fields like `marketplacePlugins` or `installStatus` appear at the top level of `Model`.
- Any `View()` switch case longer than 5 lines of logic (not rendering calls).

**Phase to address:**
Before marketplace state is introduced. Refactor the model structure as the first task of the marketplace bridge phase, before adding any new fields.

---

### Pitfall 4: Async TUI Operations Without Cancellation — Hung States

**What goes wrong:**
The existing TUI fires async `tea.Cmd` functions (org loading, syncing) and waits for messages. Adding marketplace operations introduces longer-running async work: querying a remote GitHub API, running `claude plugin install` as a subprocess, scanning multiple repos for installed plugins. If the user quits mid-operation, or the remote is unreachable, the goroutine hangs. The spinner keeps spinning. The TUI appears frozen. On quit, the program may hang waiting for the goroutine to finish.

**Why it happens:**
`tea.Cmd` functions in Bubble Tea are goroutines with no built-in cancellation. The existing code (see `syncAll()`, `Init()`) has no context cancellation. Local filesystem operations are fast enough that this doesn't matter. Network operations and subprocess waits are not.

**How to avoid:**
- Wrap all network and subprocess operations in Go `context.Context` with a timeout (30 seconds for GitHub API, configurable for `claude` CLI).
- Pass a cancellation channel or context into async commands. On `ctrl+c` / `q`, signal cancellation before calling `tea.Quit`.
- Show a "cancelling..." state when quit is pressed during an in-progress operation, then quit once the goroutine returns.
- Test the timeout path: what does the TUI show when GitHub is unreachable?

**Warning signs:**
- New `tea.Cmd` functions that call `http.Get()` or `exec.Command()` without a context.
- No `context.WithTimeout()` anywhere in marketplace-touching code.
- `ctrl+c` during a publish/install operation leaves a zombie `claude` subprocess.

**Phase to address:**
Marketplace phase, specifically when adding the GitHub query and `claude plugin install` shell-out.

---

### Pitfall 5: Message Type Collision — New Async Messages Corrupt Existing State

**What goes wrong:**
The existing TUI has two message types: `orgsLoaded` and `syncDone`. Adding marketplace operations adds new message types: `marketplaceScanned`, `pluginInstallDone`, `remoteQueryDone`. If these messages arrive while the TUI is in an unexpected state (e.g., `marketplaceScanned` arrives while the user is mid-sync), the `Update()` handler applies state mutations that corrupt the existing view. Partial state updates cause rendering errors or blank views.

**Why it happens:**
In Bubble Tea, all messages from all goroutines go to the same `Update()` function. There is no channel isolation. A message fired during view A can arrive during view B. The existing code handles this acceptably because `orgsLoaded` and `syncDone` are non-overlapping by design. With more async operations in flight simultaneously, this assumption breaks.

**How to avoid:**
- Each async operation should carry an operation ID or epoch counter. `Update()` discards messages whose operation ID doesn't match the current one.
- Never allow two async operations to run simultaneously without explicit sequencing. If a marketplace scan is in progress, disable the sync keybinding.
- State mutations in `Update()` should be defensive: check that the expected view/state is active before applying.
- Consider a message envelope: `type Msg struct { Op string; Payload any }` to make routing explicit.

**Warning signs:**
- Multiple `tea.Cmd` goroutines can be in-flight simultaneously with no coordination.
- `Update()` applies `orgsLoaded` mutations regardless of current view.
- New message types update fields that are also written by existing message handlers.

**Phase to address:**
Before introducing any new async commands — harden the message handling architecture first.

---

### Pitfall 6: Snapshot Versioning Without Version Enforcement

**What goes wrong:**
The PROJECT.md specifies a snapshot model: published plugins freeze at a version. But if `marketplace.json` doesn't include a version field, or if Chaparral regenerates it without incrementing a version, users who already installed a plugin won't know it's been updated. Worse: Claude Code may cache the old version indefinitely because the version hasn't changed. The user edits a skill, runs `chaparral publish`, the remote file changes, but installed copies remain stale.

**Why it happens:**
Version management feels like premature complexity during initial implementation. Developers skip it. The first version works fine. Then skills get updated and nobody knows why their installed version doesn't have the new behavior.

**How to avoid:**
- Generate versions as semantic version strings (`1.0.0`, not dates or hashes). Increment patch automatically on each publish.
- Store the current version in `chaparral.json` manifest under a `plugin_version` field. Chaparral owns it; the user doesn't manage it manually.
- On publish, compare generated `plugin.json` to the previously published version. If content changed, increment version. If unchanged, skip publish with a "nothing changed" message.
- Show the version prominently in the publish confirmation view.

**Warning signs:**
- `plugin.json` contains no `version` field, or always the same version.
- `chaparral.json` has no field for tracking current version.
- Two sequential publishes with different skill content produce identical `marketplace.json`.

**Phase to address:**
Manifest generation phase. Version management must be in place before the first publish is possible.

---

### Pitfall 7: Shell-Out to `claude` CLI — Subprocess Failure Is Invisible

**What goes wrong:**
`claude plugin install plugin-name@marketplace` shells out to the `claude` CLI. If the claude CLI is not installed, is an old version, requires interactive authentication, or exits with a non-zero code for a non-obvious reason, Chaparral gets back an exit code and stderr. If that error isn't surfaced clearly in the TUI, the user sees the spinner stop and thinks the install succeeded — but nothing was installed.

**Why it happens:**
Shell-outs are treated as black boxes. The calling code checks exit code 0 = success, non-zero = "error", and renders a generic error message. But subprocess errors are often multiline, contextual, and require the full stderr to understand. TUIs suppress stderr by default when running with `tea.WithAltScreen()`.

**How to avoid:**
- Capture both stdout and stderr from `exec.Command("claude", ...)`. Surface the full stderr in the TUI results view, not just "install failed."
- Check that `claude` exists in PATH before attempting the shell-out. If not, show a clear message: "claude CLI not found — install it from claude.ai/cli."
- Test the failure path: run with a mock `claude` that returns exit code 1 with stderr. Verify the TUI renders the error legibly.
- Add a `chaparral doctor` command (or embed the check in status) that verifies the claude CLI is available.

**Warning signs:**
- `exec.Command("claude", ...).Run()` called without capturing `CombinedOutput()` or `Stderr`.
- Error message shown in TUI is "install failed" with no detail.
- No pre-flight check for `claude` CLI existence.

**Phase to address:**
Plugin install phase. Never ship the install feature without capturing and rendering subprocess stderr.

---

## Technical Debt Patterns

| Shortcut | Immediate Benefit | Long-term Cost | When Acceptable |
|----------|-------------------|----------------|-----------------|
| Build marketplace JSON with `map[string]any` instead of typed structs | Faster to write | Format drift goes undetected; no compile-time safety; test surface disappears | Never — use typed structs from day one |
| Reuse `Model` for all new state fields | No refactoring required | `Update()` becomes unreadable; state validity by view becomes impossible to reason about | MVP only if refactor is planned for next phase |
| Skip version incrementing in first publish | Simplifies initial implementation | Users can't distinguish stale installs; Claude Code cache never invalidates | Never — versioning must ship with publish |
| Hardcode GitHub API base URL | One less config field | Breaks for GitHub Enterprise users; impossible to test without real network | Acceptable for v1 if documented as limitation |
| Fire `git push` without diff preview | Faster publish flow | Accidental publish; no user confidence in what changed | Never |

---

## Integration Gotchas

| Integration | Common Mistake | Correct Approach |
|-------------|----------------|------------------|
| `claude plugin install` CLI | Assume it's always installed and in PATH | Check `exec.LookPath("claude")` before any install attempt; surface actionable error if absent |
| GitHub API (for remote registry queries) | Use unauthenticated requests, hit rate limit at 60/hour | Support `GITHUB_TOKEN` env var; surface clear rate-limit error; cache query results for the session |
| `git push` via `exec.Command` | Inherit user's git auth without checking it | Pre-flight: verify remote exists, user has push access; never push without explicit confirmation |
| `plugin.json` / `marketplace.json` | Write directly to brand repo without checking for existing non-Chaparral files | Check if `.claude-plugin/` already exists and was not created by Chaparral; warn before overwriting |
| Bubble Tea `tea.WithAltScreen()` | Assume subprocess output is visible | It isn't — capture all subprocess output explicitly; render it in the TUI view |

---

## Performance Traps

| Trap | Symptoms | Prevention | When It Breaks |
|------|----------|------------|----------------|
| Scanning all repos for installed plugins on every refresh | `r` key causes 2-3 second pause in large orgs | Cache scan results keyed by mtime of `.claude/plugins/` dirs; only re-scan changed repos | > 10 repos in an org |
| GitHub API query on every dashboard open | Cold start takes 3+ seconds; timeouts when offline | Query remote registry lazily (on-demand, not on init); cache results with TTL; show "offline" gracefully | Every startup with network latency |
| Running `claude plugin install` synchronously blocking the TUI | TUI freezes during install; no way to cancel | Always run install as async `tea.Cmd`; show spinner; support cancellation | Every install — synchronous is never acceptable in a TUI |
| Walking sibling repos for plugin status during `StatusOrg` | Discovery already scans filesystem; adding plugin scan doubles I/O | Batch all filesystem reads for a repo into one pass; don't call separate scan functions per repo | > 5 repos in an org |

---

## Security Mistakes

| Mistake | Risk | Prevention |
|---------|------|------------|
| Publishing skills that contain API keys or secrets | Secret exposure via public GitHub repo | Scan skill content for common secret patterns (env var names, PEM headers) before generating manifest; warn but don't block |
| Trusting `chaparral.json` from an arbitrary repo without bounds checking | Malicious manifest triggers git push to attacker-controlled remote | Validate that the publish remote matches the org's declared brand repo; never push to a remote not in the manifest |
| Shell-injecting user-supplied plugin names into `claude plugin install` | Command injection if plugin name contains shell metacharacters | Always use `exec.Command("claude", "plugin", "install", pluginName)` with separate args — never build shell strings with user input |
| Storing GitHub tokens in `chaparral.json` | Token committed to repo | Never read auth tokens from the manifest; always use env vars or OS keychain; document this explicitly |

---

## UX Pitfalls

| Pitfall | User Impact | Better Approach |
|---------|-------------|-----------------|
| Showing local skill status and marketplace plugin status in the same list without visual distinction | User can't tell which skills are symlinked locally vs installed from marketplace | Use different symbols/colors for local vs marketplace; add a legend; consider separate sub-tabs |
| Marketplace tab appears identical to Skills tab when no marketplace is configured | User sees an empty tab with no guidance | Empty state should explain what a marketplace is and how to generate one; link to help |
| Publish confirmation that just says "publish?" without showing what will change | User publishes old or wrong version unknowingly | Show: version being published, files being added/changed in `.claude-plugin/`, target remote, last published version |
| Install shows spinner then "done" with no detail on what was installed or where | User doesn't know if install succeeded or what it changed | Show: plugin name, version installed, where it was cached, which repos it's now available in |
| Error messages from subprocess failures rendered as raw stderr | Multiline Go errors or `claude` CLI output overwhelms the TUI | Wrap long errors; show first line prominently; offer scrollable detail view or copy-to-clipboard |

---

## "Looks Done But Isn't" Checklist

- [ ] **Manifest generation:** Verify generated `plugin.json` round-trips through `json.Unmarshal` into the typed struct without data loss — missing fields silently become zero values.
- [ ] **Publish flow:** Verify that quitting mid-publish (during git operations) leaves the working tree in a clean state — no partial commits, no uncommitted changes.
- [ ] **Plugin install:** Verify that install failure (claude CLI not found, network down, bad plugin name) renders the full error in the TUI and does not show a success state.
- [ ] **Version tracking:** Verify that two sequential publishes with identical skill content do NOT increment the version or push a new commit.
- [ ] **Marketplace scan:** Verify that repos with no `.claude/` directory are correctly reported as "no plugins installed" rather than causing an error.
- [ ] **Remote query:** Verify that the TUI is fully usable offline — remote query failure degrades gracefully without blocking local skill operations.
- [ ] **Tab extension:** Verify that adding a "marketplace" tab does not break existing Skills/Repos tab navigation, cursor state, or keybindings.
- [ ] **Subprocess capture:** Verify that running `chaparral` with `tea.WithAltScreen()` and triggering an install correctly captures and renders subprocess output that would otherwise go to the hidden TTY.

---

## Recovery Strategies

| Pitfall | Recovery Cost | Recovery Steps |
|---------|---------------|----------------|
| Published wrong version of skills | MEDIUM | Publish a new version with corrected skills; version bump makes it visible; document in changelog |
| Accidental git push of sensitive skill content | HIGH | Immediately rotate any exposed secrets; force-push to remove from history (requires Chaparral to never be the only safeguard — user must understand what they publish) |
| Model bloat reached before refactor | HIGH | Extract child models; requires rewriting `Update()` and `View()` routing; test coverage essential to avoid regressions |
| Subprocess hang on quit | LOW | Add context cancellation; fix is localized to the async command wrapper |
| Format drift breaks all installs | HIGH | Update typed structs to new format; republish all affected marketplaces; add format version field to detect drift earlier next time |

---

## Pitfall-to-Phase Mapping

| Pitfall | Prevention Phase | Verification |
|---------|------------------|--------------|
| Format assumption drift | Manifest generation (first) | Test: generated output matches typed struct; validate command exists |
| Accidental publish | GitHub publishing phase | Test: publish requires two-step confirm; single keypress cannot trigger push |
| Model bloat | Before marketplace state added | Review: `Model` struct under 15 fields; `Update()` under 80 lines |
| Async without cancellation | Marketplace async commands | Test: `ctrl+c` during network op exits cleanly within 5 seconds |
| Message type collision | Before new async commands added | Test: receiving marketplace message during sync does not corrupt sync state |
| Snapshot without versioning | Manifest generation (first) | Test: two sequential publishes with changed content produce different version strings |
| Subprocess failure invisible | Plugin install phase | Test: install with missing `claude` CLI renders actionable error |

---

## Sources

- Codebase analysis: `/Users/jem/code/manzanita-research/chaparral/internal/` — all Go source files read and analyzed directly.
- Existing concerns: `.planning/codebase/CONCERNS.md` — pre-existing issues that inform extension risk areas.
- Project requirements: `.planning/PROJECT.md` — milestone scope and constraints.
- Domain knowledge: Established patterns from npm publish tooling, Homebrew formula generators, VSCode extension marketplaces, and Go Bubble Tea application architecture. MEDIUM confidence — no external verification available (search tools unavailable during this session).
- Bubble Tea model composition: `charmbracelet/bubbletea` README and community patterns (training knowledge, MEDIUM confidence).

---
*Pitfalls research for: Chaparral marketplace bridge — Go CLI/TUI*
*Researched: 2026-02-24*
