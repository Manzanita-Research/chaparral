package publisher

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"time"

	"github.com/manzanita-research/chaparral/internal/config"
	"github.com/manzanita-research/chaparral/internal/generator"
)

const initialVersion = "0.1.0"

// WrittenFile describes a file that was written to disk.
type WrittenFile struct {
	Path  string // relative to brand repo root
	IsNew bool   // true if file didn't exist before
}

// FileChange describes a change that would be made to a file.
type FileChange struct {
	Path       string // relative to brand repo root
	Kind       string // "new", "modified", "unchanged"
	OldContent string
	NewContent string
}

// FreshnessResult describes whether a skill's published manifest is stale.
type FreshnessResult struct {
	Skill            string
	Stale            bool
	PublishedVersion string // empty if not yet published
}

// bumpVersion reads the existing plugin.json for a skill and returns the next
// patch version. Returns "0.1.0" if the file is missing or unparseable.
func bumpVersion(brandRepoPath, skillsDir, skillName string) string {
	pluginPath := filepath.Join(brandRepoPath, skillsDir, skillName, "plugin.json")
	data, err := os.ReadFile(pluginPath)
	if err != nil {
		return initialVersion
	}
	var pm struct {
		Version string `json:"version"`
	}
	if err := json.Unmarshal(data, &pm); err != nil || pm.Version == "" {
		return initialVersion
	}
	var major, minor, patch int
	if _, err := fmt.Sscanf(pm.Version, "%d.%d.%d", &major, &minor, &patch); err != nil {
		return initialVersion
	}
	return fmt.Sprintf("%d.%d.%d", major, minor, patch+1)
}

// generateVersionedPlugin generates a plugin.json with the next bumped version.
// Returns the JSON content as a string (with trailing newline).
func generateVersionedPlugin(skill config.Skill, brandRepoPath string, org config.Org) (string, error) {
	data, err := generator.GeneratePluginJSON(skill)
	if err != nil {
		return "", fmt.Errorf("generating plugin for %s: %w", skill.Name, err)
	}

	version := bumpVersion(brandRepoPath, org.Manifest.SkillsDir, skill.Name)

	var manifest generator.PluginManifest
	if err := json.Unmarshal(data, &manifest); err != nil {
		return "", fmt.Errorf("parsing generated manifest for %s: %w", skill.Name, err)
	}
	manifest.Version = version
	data, err = json.MarshalIndent(manifest, "", "  ")
	if err != nil {
		return "", fmt.Errorf("marshaling manifest for %s: %w", skill.Name, err)
	}
	return string(data) + "\n", nil
}

// generateVersionedMarketplace generates a marketplace.json with bumped versions.
// Returns the JSON content as a string (with trailing newline).
func generateVersionedMarketplace(org config.Org, skills []config.Skill, brandRepoPath string) (string, error) {
	marketplaceData, err := generator.GenerateMarketplaceJSON(org, skills)
	if err != nil {
		return "", fmt.Errorf("generating marketplace: %w", err)
	}

	var marketplace generator.MarketplaceManifest
	if err := json.Unmarshal(marketplaceData, &marketplace); err != nil {
		return "", fmt.Errorf("parsing marketplace: %w", err)
	}
	for i, plugin := range marketplace.Plugins {
		for _, skill := range skills {
			if plugin.Name == skill.Name || filepath.Base(plugin.Source) == skill.Name {
				version := bumpVersion(brandRepoPath, org.Manifest.SkillsDir, skill.Name)
				marketplace.Plugins[i].Version = version
				break
			}
		}
	}
	marketplaceData, err = json.MarshalIndent(marketplace, "", "  ")
	if err != nil {
		return "", fmt.Errorf("marshaling marketplace: %w", err)
	}
	return string(marketplaceData) + "\n", nil
}

// shouldSkipSkill checks if a skill should be skipped during publishing.
// Returns true if the skill has a non-chaparral plugin.json.
func shouldSkipSkill(skill config.Skill) bool {
	pluginPath := filepath.Join(skill.Path, "plugin.json")
	if _, err := os.Stat(pluginPath); err == nil {
		return !isChaparralGenerated(pluginPath)
	}
	return false
}

// diffFile compares new content against an existing file on disk and returns
// the appropriate FileChange.
func diffFile(absPath, relPath, newContent string) (FileChange, error) {
	change := FileChange{Path: relPath, NewContent: newContent}

	existing, err := os.ReadFile(absPath)
	if os.IsNotExist(err) {
		change.Kind = "new"
	} else if err != nil {
		return change, fmt.Errorf("reading %s: %w", absPath, err)
	} else {
		change.OldContent = string(existing)
		if change.OldContent == newContent {
			change.Kind = "unchanged"
		} else {
			change.Kind = "modified"
		}
	}
	return change, nil
}

// isChaparralGenerated checks if an existing plugin.json was generated by
// chaparral by looking for the "skills" field with value "./".
func isChaparralGenerated(path string) bool {
	data, err := os.ReadFile(path)
	if err != nil {
		return false
	}
	var pm struct {
		Skills string `json:"skills"`
	}
	if err := json.Unmarshal(data, &pm); err != nil {
		return false
	}
	return pm.Skills == "./"
}

// WriteManifests generates and writes plugin.json for each skill and
// marketplace.json for the org. Returns the list of written files.
// Skills with existing non-chaparral plugin.json files are skipped.
func WriteManifests(org config.Org, skills []config.Skill) ([]WrittenFile, error) {
	brandRepoPath := filepath.Join(org.Path, org.BrandRepo)
	var written []WrittenFile
	var publishedSkills []config.Skill

	for _, skill := range skills {
		if shouldSkipSkill(skill) {
			continue
		}

		content, err := generateVersionedPlugin(skill, brandRepoPath, org)
		if err != nil {
			return nil, err
		}

		pluginPath := filepath.Join(skill.Path, "plugin.json")
		_, statErr := os.Stat(pluginPath)
		isNew := os.IsNotExist(statErr)

		if err := os.WriteFile(pluginPath, []byte(content), 0644); err != nil {
			return nil, fmt.Errorf("writing %s: %w", pluginPath, err)
		}

		relPath, _ := filepath.Rel(brandRepoPath, pluginPath)
		written = append(written, WrittenFile{Path: relPath, IsNew: isNew})
		publishedSkills = append(publishedSkills, skill)
	}

	if len(publishedSkills) > 0 {
		content, err := generateVersionedMarketplace(org, publishedSkills, brandRepoPath)
		if err != nil {
			return nil, err
		}

		pluginDir := filepath.Join(brandRepoPath, ".claude-plugin")
		if err := os.MkdirAll(pluginDir, 0755); err != nil {
			return nil, fmt.Errorf("creating .claude-plugin: %w", err)
		}

		marketplacePath := filepath.Join(pluginDir, "marketplace.json")
		_, statErr := os.Stat(marketplacePath)
		isNew := os.IsNotExist(statErr)

		if err := os.WriteFile(marketplacePath, []byte(content), 0644); err != nil {
			return nil, fmt.Errorf("writing marketplace.json: %w", err)
		}

		relPath, _ := filepath.Rel(brandRepoPath, marketplacePath)
		written = append(written, WrittenFile{Path: relPath, IsNew: isNew})
	}

	return written, nil
}

// bumpVersionFromFile reads the version from an existing plugin.json file.
func bumpVersionFromFile(path string) string {
	data, err := os.ReadFile(path)
	if err != nil {
		return initialVersion
	}
	var pm struct {
		Version string `json:"version"`
	}
	if err := json.Unmarshal(data, &pm); err != nil || pm.Version == "" {
		return initialVersion
	}
	return pm.Version
}

// DiffManifests produces a read-only diff of what WriteManifests would do.
// It generates the same content as WriteManifests but compares against
// existing files on disk instead of writing.
func DiffManifests(org config.Org, skills []config.Skill) ([]FileChange, error) {
	brandRepoPath := filepath.Join(org.Path, org.BrandRepo)
	var changes []FileChange
	var publishedSkills []config.Skill

	for _, skill := range skills {
		if shouldSkipSkill(skill) {
			continue
		}

		content, err := generateVersionedPlugin(skill, brandRepoPath, org)
		if err != nil {
			return nil, err
		}

		pluginPath := filepath.Join(skill.Path, "plugin.json")
		relPath, _ := filepath.Rel(brandRepoPath, pluginPath)

		change, err := diffFile(pluginPath, relPath, content)
		if err != nil {
			return nil, err
		}

		changes = append(changes, change)
		publishedSkills = append(publishedSkills, skill)
	}

	if len(publishedSkills) > 0 {
		content, err := generateVersionedMarketplace(org, publishedSkills, brandRepoPath)
		if err != nil {
			return nil, err
		}

		marketplacePath := filepath.Join(brandRepoPath, ".claude-plugin", "marketplace.json")
		relPath, _ := filepath.Rel(brandRepoPath, marketplacePath)

		change, err := diffFile(marketplacePath, relPath, content)
		if err != nil {
			return nil, err
		}

		changes = append(changes, change)
	}

	return changes, nil
}

// CheckFreshness reports whether each skill's source files are newer than
// its published plugin.json. When mtimes are within 1 second (post-clone
// scenario), falls back to content comparison.
func CheckFreshness(org config.Org, skills []config.Skill) ([]FreshnessResult, error) {
	brandRepoPath := filepath.Join(org.Path, org.BrandRepo)
	results := make([]FreshnessResult, 0, len(skills))

	for _, skill := range skills {
		pluginPath := filepath.Join(skill.Path, "plugin.json")
		result := FreshnessResult{Skill: skill.Name}

		pluginInfo, err := os.Stat(pluginPath)
		if os.IsNotExist(err) {
			// Never published
			result.Stale = true
			results = append(results, result)
			continue
		} else if err != nil {
			return nil, fmt.Errorf("checking %s: %w", pluginPath, err)
		}

		// Read published version
		result.PublishedVersion = bumpVersionFromFile(pluginPath)
		pluginMtime := pluginInfo.ModTime()

		// Check all files in the skill directory
		entries, err := os.ReadDir(skill.Path)
		if err != nil {
			return nil, fmt.Errorf("reading skill dir %s: %w", skill.Path, err)
		}

		stale := false
		for _, entry := range entries {
			if entry.Name() == "plugin.json" {
				continue
			}
			info, err := entry.Info()
			if err != nil {
				continue
			}

			diff := info.ModTime().Sub(pluginMtime)
			if diff > time.Second {
				// Skill file is clearly newer
				stale = true
				break
			} else if diff > -time.Second {
				// Mtimes within 1 second — fall back to content comparison
				expected, genErr := generateVersionedPlugin(skill, brandRepoPath, org)
				if genErr != nil {
					stale = true
					break
				}
				existing, readErr := os.ReadFile(pluginPath)
				if readErr != nil {
					stale = true
					break
				}
				if string(existing) != expected {
					stale = true
				}
				break
			}
			// Skill file is older — not stale from this file
		}

		result.Stale = stale
		results = append(results, result)
	}

	return results, nil
}
