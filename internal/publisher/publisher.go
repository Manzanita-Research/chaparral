package publisher

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"time"

	"github.com/manzanita-research/chaparral/internal/config"
	"github.com/manzanita-research/chaparral/internal/generator"
)

const initialVersion = "0.1.0"

// WrittenFile describes a file that was written to disk.
type WrittenFile struct {
	Path  string // relative to brand repo root
	IsNew bool   // true if file didn't exist before
}

// FileChange describes a change that would be made to a file.
type FileChange struct {
	Path       string // relative to brand repo root
	Kind       string // "new", "modified", "unchanged"
	OldContent string
	NewContent string
}

// FreshnessResult describes whether a skill's published manifest is stale.
type FreshnessResult struct {
	Skill            string
	Stale            bool
	PublishedVersion string // empty if not yet published
}

// bumpVersion reads the existing plugin.json for a skill and returns the next
// patch version. Returns "0.1.0" if the file is missing or unparseable.
func bumpVersion(brandRepoPath, skillsDir, skillName string) string {
	pluginPath := filepath.Join(brandRepoPath, skillsDir, skillName, "plugin.json")
	data, err := os.ReadFile(pluginPath)
	if err != nil {
		return initialVersion
	}
	var pm struct {
		Version string `json:"version"`
	}
	if err := json.Unmarshal(data, &pm); err != nil || pm.Version == "" {
		return initialVersion
	}
	var major, minor, patch int
	if _, err := fmt.Sscanf(pm.Version, "%d.%d.%d", &major, &minor, &patch); err != nil {
		return initialVersion
	}
	return fmt.Sprintf("%d.%d.%d", major, minor, patch+1)
}

// isChaparralGenerated checks if an existing plugin.json was generated by
// chaparral by looking for the "skills" field with value "./".
func isChaparralGenerated(path string) bool {
	data, err := os.ReadFile(path)
	if err != nil {
		return false
	}
	var pm struct {
		Skills string `json:"skills"`
	}
	if err := json.Unmarshal(data, &pm); err != nil {
		return false
	}
	return pm.Skills == "./"
}

// WriteManifests generates and writes plugin.json for each skill and
// marketplace.json for the org. Returns the list of written files.
// Skills with existing non-chaparral plugin.json files are skipped.
func WriteManifests(org config.Org, skills []config.Skill) ([]WrittenFile, error) {
	brandRepoPath := filepath.Join(org.Path, org.BrandRepo)
	var written []WrittenFile
	var publishedSkills []config.Skill

	for _, skill := range skills {
		pluginPath := filepath.Join(skill.Path, "plugin.json")

		// Check if existing plugin.json is not from chaparral
		if _, err := os.Stat(pluginPath); err == nil {
			if !isChaparralGenerated(pluginPath) {
				// Skip this skill but continue with others
				continue
			}
		}

		// Generate plugin manifest
		data, err := generator.GeneratePluginJSON(skill)
		if err != nil {
			return nil, fmt.Errorf("generating plugin for %s: %w", skill.Name, err)
		}

		// Bump version
		version := bumpVersion(brandRepoPath, org.Manifest.SkillsDir, skill.Name)

		// Unmarshal, set version, re-marshal
		var manifest generator.PluginManifest
		if err := json.Unmarshal(data, &manifest); err != nil {
			return nil, fmt.Errorf("parsing generated manifest for %s: %w", skill.Name, err)
		}
		manifest.Version = version
		data, err = json.MarshalIndent(manifest, "", "  ")
		if err != nil {
			return nil, fmt.Errorf("marshaling manifest for %s: %w", skill.Name, err)
		}

		// Check if file is new
		_, statErr := os.Stat(pluginPath)
		isNew := os.IsNotExist(statErr)

		if err := os.WriteFile(pluginPath, append(data, '\n'), 0644); err != nil {
			return nil, fmt.Errorf("writing %s: %w", pluginPath, err)
		}

		relPath, _ := filepath.Rel(brandRepoPath, pluginPath)
		written = append(written, WrittenFile{Path: relPath, IsNew: isNew})
		publishedSkills = append(publishedSkills, skill)
	}

	// Write marketplace.json
	if len(publishedSkills) > 0 {
		marketplaceData, err := generator.GenerateMarketplaceJSON(org, publishedSkills)
		if err != nil {
			return nil, fmt.Errorf("generating marketplace: %w", err)
		}

		// Update versions in marketplace to match what we just wrote
		var marketplace generator.MarketplaceManifest
		if err := json.Unmarshal(marketplaceData, &marketplace); err != nil {
			return nil, fmt.Errorf("parsing marketplace: %w", err)
		}
		for i, plugin := range marketplace.Plugins {
			// Find the matching skill and read its version from the just-written plugin.json
			for _, skill := range publishedSkills {
				if plugin.Name == skill.Name || filepath.Base(plugin.Source) == skill.Name {
					version := bumpVersionFromFile(filepath.Join(skill.Path, "plugin.json"))
					marketplace.Plugins[i].Version = version
					break
				}
			}
		}
		marketplaceData, err = json.MarshalIndent(marketplace, "", "  ")
		if err != nil {
			return nil, fmt.Errorf("marshaling marketplace: %w", err)
		}

		pluginDir := filepath.Join(brandRepoPath, ".claude-plugin")
		if err := os.MkdirAll(pluginDir, 0755); err != nil {
			return nil, fmt.Errorf("creating .claude-plugin: %w", err)
		}

		marketplacePath := filepath.Join(pluginDir, "marketplace.json")
		_, statErr := os.Stat(marketplacePath)
		isNew := os.IsNotExist(statErr)

		if err := os.WriteFile(marketplacePath, append(marketplaceData, '\n'), 0644); err != nil {
			return nil, fmt.Errorf("writing marketplace.json: %w", err)
		}

		relPath, _ := filepath.Rel(brandRepoPath, marketplacePath)
		written = append(written, WrittenFile{Path: relPath, IsNew: isNew})
	}

	return written, nil
}

// bumpVersionFromFile reads the version from an existing plugin.json file.
func bumpVersionFromFile(path string) string {
	data, err := os.ReadFile(path)
	if err != nil {
		return initialVersion
	}
	var pm struct {
		Version string `json:"version"`
	}
	if err := json.Unmarshal(data, &pm); err != nil || pm.Version == "" {
		return initialVersion
	}
	return pm.Version
}

// DiffManifests produces a read-only diff of what WriteManifests would do.
// It generates the same content as WriteManifests but compares against
// existing files on disk instead of writing.
func DiffManifests(org config.Org, skills []config.Skill) ([]FileChange, error) {
	brandRepoPath := filepath.Join(org.Path, org.BrandRepo)
	var changes []FileChange
	var publishedSkills []config.Skill

	for _, skill := range skills {
		pluginPath := filepath.Join(skill.Path, "plugin.json")

		// Check if existing plugin.json is not from chaparral
		if _, err := os.Stat(pluginPath); err == nil {
			if !isChaparralGenerated(pluginPath) {
				continue
			}
		}

		// Generate plugin manifest with bumped version
		data, err := generator.GeneratePluginJSON(skill)
		if err != nil {
			return nil, fmt.Errorf("generating plugin for %s: %w", skill.Name, err)
		}

		version := bumpVersion(brandRepoPath, org.Manifest.SkillsDir, skill.Name)

		var manifest generator.PluginManifest
		if err := json.Unmarshal(data, &manifest); err != nil {
			return nil, fmt.Errorf("parsing generated manifest for %s: %w", skill.Name, err)
		}
		manifest.Version = version
		data, err = json.MarshalIndent(manifest, "", "  ")
		if err != nil {
			return nil, fmt.Errorf("marshaling manifest for %s: %w", skill.Name, err)
		}
		newContent := string(data) + "\n"

		relPath, _ := filepath.Rel(brandRepoPath, pluginPath)
		change := FileChange{Path: relPath, NewContent: newContent}

		existing, err := os.ReadFile(pluginPath)
		if os.IsNotExist(err) {
			change.Kind = "new"
		} else if err != nil {
			return nil, fmt.Errorf("reading %s: %w", pluginPath, err)
		} else {
			change.OldContent = string(existing)
			if change.OldContent == newContent {
				change.Kind = "unchanged"
			} else {
				change.Kind = "modified"
			}
		}

		changes = append(changes, change)
		publishedSkills = append(publishedSkills, skill)
	}

	// Diff marketplace.json
	if len(publishedSkills) > 0 {
		marketplaceData, err := generator.GenerateMarketplaceJSON(org, publishedSkills)
		if err != nil {
			return nil, fmt.Errorf("generating marketplace: %w", err)
		}

		// Update versions to match what we'd write
		var marketplace generator.MarketplaceManifest
		if err := json.Unmarshal(marketplaceData, &marketplace); err != nil {
			return nil, fmt.Errorf("parsing marketplace: %w", err)
		}
		for i, plugin := range marketplace.Plugins {
			for _, skill := range publishedSkills {
				if plugin.Name == skill.Name || filepath.Base(plugin.Source) == skill.Name {
					version := bumpVersion(brandRepoPath, org.Manifest.SkillsDir, skill.Name)
					marketplace.Plugins[i].Version = version
					break
				}
			}
		}
		marketplaceData, err = json.MarshalIndent(marketplace, "", "  ")
		if err != nil {
			return nil, fmt.Errorf("marshaling marketplace: %w", err)
		}
		newContent := string(marketplaceData) + "\n"

		marketplacePath := filepath.Join(brandRepoPath, ".claude-plugin", "marketplace.json")
		relPath, _ := filepath.Rel(brandRepoPath, marketplacePath)
		change := FileChange{Path: relPath, NewContent: newContent}

		existing, err := os.ReadFile(marketplacePath)
		if os.IsNotExist(err) {
			change.Kind = "new"
		} else if err != nil {
			return nil, fmt.Errorf("reading %s: %w", marketplacePath, err)
		} else {
			change.OldContent = string(existing)
			if change.OldContent == newContent {
				change.Kind = "unchanged"
			} else {
				change.Kind = "modified"
			}
		}

		changes = append(changes, change)
	}

	return changes, nil
}

// CheckFreshness reports whether each skill's source files are newer than
// its published plugin.json. When mtimes are within 1 second (post-clone
// scenario), falls back to content comparison.
func CheckFreshness(org config.Org, skills []config.Skill) ([]FreshnessResult, error) {
	brandRepoPath := filepath.Join(org.Path, org.BrandRepo)
	results := make([]FreshnessResult, 0, len(skills))

	for _, skill := range skills {
		pluginPath := filepath.Join(skill.Path, "plugin.json")
		result := FreshnessResult{Skill: skill.Name}

		pluginInfo, err := os.Stat(pluginPath)
		if os.IsNotExist(err) {
			// Never published
			result.Stale = true
			results = append(results, result)
			continue
		} else if err != nil {
			return nil, fmt.Errorf("checking %s: %w", pluginPath, err)
		}

		// Read published version
		result.PublishedVersion = bumpVersionFromFile(pluginPath)
		pluginMtime := pluginInfo.ModTime()

		// Check all files in the skill directory
		entries, err := os.ReadDir(skill.Path)
		if err != nil {
			return nil, fmt.Errorf("reading skill dir %s: %w", skill.Path, err)
		}

		stale := false
		for _, entry := range entries {
			if entry.Name() == "plugin.json" {
				continue
			}
			info, err := entry.Info()
			if err != nil {
				continue
			}

			diff := info.ModTime().Sub(pluginMtime)
			if diff > time.Second {
				// Skill file is clearly newer
				stale = true
				break
			} else if diff > -time.Second {
				// Mtimes within 1 second — fall back to content comparison
				generated, genErr := generator.GeneratePluginJSON(skill)
				if genErr != nil {
					stale = true
					break
				}
				// Also account for version bump
				version := bumpVersion(brandRepoPath, org.Manifest.SkillsDir, skill.Name)
				var manifest generator.PluginManifest
				if err := json.Unmarshal(generated, &manifest); err != nil {
					stale = true
					break
				}
				manifest.Version = version
				newData, err := json.MarshalIndent(manifest, "", "  ")
				if err != nil {
					stale = true
					break
				}

				existing, readErr := os.ReadFile(pluginPath)
				if readErr != nil {
					stale = true
					break
				}
				if string(existing) != string(newData)+"\n" {
					stale = true
				}
				break
			}
			// Skill file is older — not stale from this file
		}

		result.Stale = stale
		results = append(results, result)
	}

	return results, nil
}
